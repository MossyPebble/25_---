<!DOCTYPE html>
<html>

<head>
    <title>PCM Player</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <link rel="icon" href="image/favicon.ico" type="image/x-icon">
    <script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js" charset="utf-8"></script>
    <script src="https://unpkg.com/pcm-player"></script>
</head>
<style>
    body {
        font-family: 'Roboto', sans-serif;
    }

    .button {
        border: none;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
    }
</style>

<body>
    <h1>ESP32-S3 + I²S Digital Microphone</h1>
    <p>Connect to WebSocket by pressing the [Connect] button first!</p>
    <button id="connectBtn" class="button" onclick="connect()">Connect</button>
    <input type="range" max="1" value="0.5" min="0" id="range" onchange="changeVolume(event)" step="0.1"><br />
    <button id="pauseBtn" class="button" onclick="pause()">Pause Playing</button>
    <button id="continueBtn" class="button" onclick="continuePlay()">Continue Playing</button>
    <div id="graph"></div>
    <script>
        function addDarkmodeWidget() {
            new Darkmode().showWidget();
        }
        window.addEventListener('load', addDarkmodeWidget);

        var connectBtn = document.getElementById("connectBtn");
        var pauseBtn = document.getElementById("pauseBtn");
        var continueBtn = document.getElementById("continueBtn");
        connectBtn.disabled = false;
        pauseBtn.disabled = true;
        continueBtn.disabled = true;

        const arrayLength = 100;
        var graphDataArray = Array(arrayLength).fill(0);

        var layout = {
            title: 'Streaming Data',
            paper_bgcolor: "#000",
            plot_bgcolor: "#000",
            xaxis: {
                domain: [0, 1],
                showticklabels: false,
                color: "#FFF",
            },
            yaxis: {
                domain: [0, 1],
                color: "#FFF",
                rangemode: "auto",
            },
        };

        Plotly.newPlot('graph', [{
            y: graphDataArray,
            mode: 'lines',
            line: { color: '#DF56F1' }
        }], layout);

        let player;
        let worker;

        window.connect = function connect() {
            connectBtn.disabled = true;
            pauseBtn.disabled = false;

            player = new PCMPlayer({
                inputCodec: 'Int16',
                channels: 1,
                sampleRate: 16000
            });

            // 인라인 Web Worker 생성
            const workerBlob = new Blob([`
                self.addEventListener('message', function (e) {
                    var mean = 0;
                    var samples_read = e.data.byteLength / 2; // Int16 데이터이므로 2바이트 단위로 나눔
                    if (samples_read > 0) {
                        var byteArray = new Int16Array(e.data);

                        for (var i = 0; i < samples_read; ++i) {
                            mean += byteArray[i];
                        }

                        mean /= samples_read;
                        self.postMessage(mean); // 평균값을 메인 스레드로 전달
                    }
                });
            `], { type: 'application/javascript' });

            worker = new Worker(URL.createObjectURL(workerBlob));
            worker.addEventListener('message', function (e) {
                // 워커에서 계산된 평균값을 그래프에 업데이트
                graphDataArray = graphDataArray.concat(e.data);
                graphDataArray.splice(0, 1);

                var data_update = {
                    y: [graphDataArray]
                };

                Plotly.update('graph', data_update);
            });

            const WS_URL = 'ws://192.168.43.210:81'; // ESP32의 IP 주소와 WebSocket 포트
            var ws = new WebSocket(WS_URL);
            ws.binaryType = 'arraybuffer';

            ws.addEventListener('message', function (event) {
                if (continueBtn.disabled) {
                    const pcmData = new Int16Array(event.data);
                    console.log("PCM Data Length:", pcmData.length); // 샘플 개수 확인
                    console.log("PCM Data:", pcmData); // PCM 데이터 내용 확인
                    player.feed(event.data);
                }

                // WebSocket으로 수신된 데이터를 워커로 전달
                worker.postMessage(event.data);
            });
        };

        window.changeVolume = function changeVolume(e) {
            player.volume(document.querySelector('#range').value);
        };

        window.pause = async function pause() {
            pauseBtn.disabled = true;
            continueBtn.disabled = false;
            await player.pause();
        };

        window.continuePlay = function continuePlay() {
            player.continue();
            pauseBtn.disabled = false;
            continueBtn.disabled = true;
        };
    </script>
</body>

</html>